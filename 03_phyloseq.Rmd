---
title: "03_Phyloseq tutorial"
output:
  github_document:
    toc: yes
    toc_depth: 5
---
Ce document R, sert pour des analyses grâce au package de phyloseq. 

# Introduction 
## Appele des librarys 

```{r}
library(ggplot2)
library(dada2)
library(phyloseq)
library(dada2)
library(ggplot2)
library(dplyr)
library(reshape2)
library(ade4)
library(ggrepel)
library(lattice)
library(igraph)
library(ggnetwork)
```

#" Les données de la rade de Brest après analyse avec dada2

```{r}
load("~/CC2_Ecog2/02_Dada2_tutorial_FinalEnv")
```

# Analyse avec phyloseq

## Combiner les données dans un objet phyloseq

-samdf = une fonction qui va permmettre de faire un graph qui englobe les ensembles de données
```{r}
samples.out <- rownames(seqtab.nochim)
profondeur <- sapply(strsplit(samples.out, "D"), `[`, 1)
date <- substr(profondeur,0,1557)
samdf <- data.frame(Profondeur=profondeur, Date=date)
samdf$Profondeur[samdf$Date>1557] <- c("Fond","Median","Surface")
samdf$Date[samdf$Profondeur>1557] <- c("10sept14","11mars15")
rownames(samdf) <- samples.out
```


```{r}
write.csv(samdf, "samdf.csv")
```
on crée une fichier samdf avec nos échantillons, nous allon réorganiser les donnée pour que les échantillons correspond a leur profondeur et leurs dates. 

```{r}
samdf <-read.table("~/CC2_Ecog2/samdf.csv", sep=",", header=TRUE, row.names = 1)
```

## Arbre phylogénétique 
```{r}
library(phangorn)
library(DECIPHER)
seqs <- getSequences(seqtab.nochim)
names(seqs) <- seqs # This propagates to the tip labels of the tree
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA,verbose=FALSE)
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)
treeNJ <- NJ(dm) # Note, tip order != sequence order
fit = pml(treeNJ, data=phangAlign)
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
        rearrangement = "stochastic", control = pml.control(trace = 0))
detach("package:phangorn", unload=TRUE)
```

```{r}
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa), phy_tree(fitGTR$tree))
ps
```

## Les indices de diversité : alpha 

Les  indices  de  diversité sont  basés  sur  des  formules  plus  complexes  et  illustrant  la  complexité  des  peuplements  : Indice  de  Shannon  Wiener  (H’),  Indice de Simpson ...  Ces indices prends en compte le  nombre  d’espèces et la  distribution des individus au sein de ces espèces. 

l’indice  de  Shannon  est  sensibles  aux  variations  d’importance  des  espèces les plus rares

l’indice de Simpson est sensibles aux variations d’importance des espèces les plus abondantes.
```{r}
plot_richness(ps, x="Date", measures=c("Shannon", "Simpson"), color="Profondeur")
```

## Filtrage de la taxonomie
### Indiquer les rangs dans l'ensemble des données

La fonction rank-names: permet de déterminer les rangs taxonomiques de ps 
```{r}
rank_names(taxa.print)
```

### Créer un tableau, nombre de caractéristiques pour chaque phyla

La fonction tax_table : permet de construire et d’accéder à une table de nom taxonomique de l’objet ps
Table : permet faire un tableau de contingence en fonction de différents facteurs, ajout tax_table, au niveau du phylum, il exclut quand ce ne sont pas des phyla. Le résultat indique le nombre de séquences appartenant au phylum désigné. Les NA sont des artefacts dans le jeu de données, ils vont être supprimés.

```{r}
table(tax_table(ps)[, "Phylum"], exclude = NULL)
```

### Créer une table avec le nombre dans chaque phyla
```{r}
ps <- subset_taxa(ps, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
```

```{r}
prevdf = apply(X = otu_table(ps),
               MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})
```

```{r}
prevdf = data.frame(Prevalence = prevdf,
                    TotalAbundance = taxa_sums(ps),
                    tax_table(ps))
```

```{r}
plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))})
```

```{r}
filterPhyla = c("Dependentiae", "Campilobacterota", "Elusimicrobiota", "Fibrobacterota", "Hydrogenedentes", "NB1-j")
```

```{r}
ps1 = subset_taxa(ps, !Phylum %in% filterPhyla)
ps1
```

```{r}
prevdf1 = subset(prevdf, Phylum %in% get_taxa_unique(ps1, "Phylum"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(ps),color=Phylum)) +
  # Include a guess for parameter
  geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +  geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")
```

Chloroflexi
```{r}
prevalenceThreshold = 0.05 * nsamples(ps)
prevalenceThreshold
```

```{r}
keepTaxa = rownames(prevdf1)[(prevdf1$Prevalence >= prevalenceThreshold)]
ps2 = prune_taxa(keepTaxa, ps)
```


```{r}
length(get_taxa_unique(ps2, taxonomic.rank = "Genus"))
```
On prend ps2 le filtrage et la prévalence, on lui assigne jusqu’au rang «genre» les ASV. Obtenir la longueur des vecteurs de ps2.

```{r}
ps3 = tax_glom(ps2, "Genus", NArm = TRUE)
```
Cette méthode permet de fusionner des espèces qui ont la même taxonomie à un certain rang taxonomique, jusqu’au «genre» à partir de ps2, on obtient alors ps3. 

```{r}
h1 = 0.4
ps4 = tip_glom(ps2, h = h1)
```

```{r}
multiPlotTitleTextSize = 15
p2tree = plot_tree(ps2, method = "treeonly",
                   ladderize = "left",
                   title = "Before Agglomeration") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p3tree = plot_tree(ps3, method = "treeonly",
                   ladderize = "left", title = "By Genus") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p4tree = plot_tree(ps4, method = "treeonly",
                   ladderize = "left", title = "By Height") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
```


```{r}
gridExtra::grid.arrange(nrow = 1, p2tree, p3tree, p4tree)
```

# Abondance 

## Selon la profondeur 
```{r}
plot_abundance_P = function(physeq,title = "",
                          Facet = "Order", Color = "Phylum"){
  # Arbitrary subset, based on Phylum, for plotting
  p1f = subset_taxa(physeq, Phylum %in% c("Cyanobacteria"))
  mphyseq = psmelt(p1f)
  mphyseq <- subset(mphyseq, Abundance > 0)
  ggplot(data = mphyseq, mapping = aes_string(x = "Profondeur",y = "Abundance",
                              color = Color, fill = Color)) +
    geom_violin(fill = NA) +
    geom_point(size = 1, alpha = 0.3,
               position = position_jitter(width = 0.3)) +
    facet_wrap(facets = Facet) + scale_y_log10()+
    theme(legend.position="none")
}
```

```{r}
ps3ra_P = transform_sample_counts(ps3, function(x){x / sum(x)})
```

```{r}
plotBefore_P = plot_abundance_P(ps3,"")
plotAfter_P = plot_abundance_P(ps3ra_P,"")
```

```{r}
gridExtra::grid.arrange(nrow = 1, plotBefore_P, plotAfter_P)
```

```{r}
psOrd_P = subset_taxa(ps3ra_P, Order == "Synechococcales")
plot_abundance_P(psOrd_P, Facet = "Genus", Color = NULL)
```




## Selon la date 
```{r}
plot_abundance_D = function(physeq,title = "",
                          Facet = "Order", Color = "Phylum"){
  # Arbitrary subset, based on Phylum, for plotting
  p1f = subset_taxa(physeq, Phylum %in% c("Cyanobacteria"))
  mphyseq = psmelt(p1f)
  mphyseq <- subset(mphyseq, Abundance > 0)
  ggplot(data = mphyseq, mapping = aes_string(x = "Date",y = "Abundance",
                              color = Color, fill = Color)) +
    geom_violin(fill = NA) +
    geom_point(size = 1, alpha = 0.3,
               position = position_jitter(width = 0.3)) +
    facet_wrap(facets = Facet) + scale_y_log10()+
    theme(legend.position="none")
}
```

```{r}
ps3ra_D = transform_sample_counts(ps3, function(x){x / sum(x)})
```

```{r}
plotBefore_D = plot_abundance_D(ps3,"")
plotAfter_D = plot_abundance_D(ps3ra_D,"")
```

```{r}
gridExtra::grid.arrange(nrow = 1, plotBefore_D, plotAfter_D)
```


```{r}
psOrd_D = subset_taxa(ps3ra_D, Order == "Synechococcales")
plot_abundance_D(psOrd_D, Facet = "Genus", Color = NULL)
```


# Ordination 

```{r}
# Transform data to proportions as appropriate for Bray-Curtis distances
ps.prop <- transform_sample_counts(ps, function(tax_table) tax_table/sum(tax_table))
ord.pcoa.bray <- ordinate(ps.prop, method="PCoA", distance="bray")
```

## Visualisation de l'ordination

```{r}
plot_ordination(ps.prop, ord.pcoa.bray, color="Profondeur", shape = "Date", title="Bray PCoA")
```


```{r}
ps <- prune_samples(rowSums(otu_table(ps)) > 1000, ps)
pslog <- transform_sample_counts(ps, function(x) log(1 + x))
```


```{r}
out.dpcoa.log <- ordinate(pslog, method = "DPCoA")
evals <- out.dpcoa.log$eig
plot_ordination(pslog, out.dpcoa.log, color = "Date", label= "SampleID",
                  shape = "Profondeur") +
  labs(col = "Date", shape = "Profondeur")+
  coord_fixed(sqrt(evals[2] / evals[1]))
```


```{r}
plot_ordination(pslog, out.dpcoa.log, type = "species", color = "Phylum") +
  coord_fixed(sqrt(evals[2] / evals[1]))
```


# Bar plot

```{r}
top20 <- names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 <- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 <- prune_taxa(top20, ps.top20)
plot_bar(ps.top20, x="Date", fill="Genus") + facet_wrap(~Profondeur, scales="free_x")
```

Pour le fond de la rade de Brest pour les deux date , on retrouve en plus grande proportion le genre de clade Ia (vert), puis en plus ptit quantité les SUP05 cluster et apres les NS5 marine group. Sachant qu'il y a une grande propotion dans les deux cas de NA. 

Pour le médian, on trouve en majorité le cladIa , puis les Synechoccocus CC9902 avec les Ascidiceihabitans dans des proportion équivalente. 

Pour la surface les Synechoccocus CC9902 domine en spetembre alors que c'est le clade IA en mars. Le deuxième genre majoritaire en spetembre est le clade IA, alors que pour mars c'est des SUP05 cluster. Sachant qu'il y a une grande propotion de non caractérisé. 

Globalement on a un genre qui se trouve dans n'importe qu'elle profondeur qu'elle que soit la date c'est le cladeIa. La seule différente entre les date que l'on peut noter pour les genre est dans la surface. En effet on les Synechoccocus CC9902 qui domine en septembre. 

A chercher en des fonction des epèce si elle est présent normalement a Brest
```{r}
top20 <- names(sort(taxa_sums(ps), decreasing=TRUE))[1:20]
ps.top20 <- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top20 <- prune_taxa(top20, ps.top20)
plot_bar(ps.top20, x="Date", fill="Order") + facet_wrap(~Profondeur, scales="free_x")
```

# Analyse en réseau 


```{r}
net <- make_network(ps, max.dist=0.35)
sampledata <- data.frame(sample_data(ps))
V(net)$date <- sampledata[names(V(net)), "Date"]
V(net)$Profondeur <- sampledata[names(V(net)), "Profondeur"]
net_graph <- ggnetwork(net)
ggplot(net_graph, aes(x = x, y = y, xend = xend, yend = yend), layout = "fruchtermanreingold") +
  geom_edges(color = "darkgray") +
  geom_nodes(aes(color = date, shape = Profondeur),  size = 3 ) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        legend.key.height = unit(0.5,"line")) +
  guides(col = guide_legend(override.aes = list(size = .5)))
```
Les échantillons prélevé en mar 2015( bleu) sont relier entre eux que sois en surface ou dans le fonds. Les communautés sont donc en lien. Les échantillons en septembre 2014 sont divisié en deux groupe. On a ceux retrouve que en fond et donc des communauté particilère, et apres les médian et fond ont de lien. 

On pourrais expliquer ce resultat. On peut supposer que la date de spetembre correspon à l'automne 2014 et que la date de mars plus au printemps un an après. Pendant l'hiver , souvent la mer est plus mouvementé du au temppête et au courant (ex: gulf stream) donc mars pourrais correspondre au conséquence de l'hivers d'ou peut être des différence entre le fond/ médian et la surface. Pour les échantillons de spetembre c'est donc après l'été , la mer est mouvementé normalement. 



# Biomarqueurs

```{r}
library(DESeq2)
```

```{r}
dds <- DESeqDataSetFromMatrix(ps, as.data.frame(samdf), ~ samdf)
```

